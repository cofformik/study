#include <reg52.h>
#include <intrins.h>
#define uchar unsigned char
#define uint unsigned int
uchar code zima[20][32]=
{
0x00,0x00,0xC0,0xE0,0x30,0x10,0x08,0x08,0x08,0x08,0x08,0x18,0x30,0xE0,0xC0,0x00,
0x00,0x00,0x07,0x0F,0x18,0x10,0x20,0x20,0x20,0x20,0x20,0x10,0x18,0x0F,0x07,0x00,///*"0"*0/
0x00,0x00,0x00,0x10,0x10,0x10,0x10,0xF0,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x20,0x20,0x20,0x20,0x3F,0x3F,0x20,0x20,0x20,0x20,0x00,0x00,0x00,///*"1"*1/
0x00,0x00,0x60,0x50,0x10,0x08,0x08,0x08,0x08,0x08,0x08,0x98,0xF0,0x70,0x00,0x00,
0x00,0x00,0x20,0x30,0x28,0x28,0x24,0x24,0x22,0x22,0x21,0x20,0x30,0x18,0x00,0x00,///*"2"*2/
0x00,0x00,0x30,0x30,0x08,0x08,0x88,0x88,0x88,0x88,0x58,0x70,0x30,0x00,0x00,0x00,
0x00,0x00,0x18,0x18,0x20,0x20,0x20,0x20,0x20,0x20,0x31,0x11,0x1F,0x0E,0x00,0x00,///*"3"*3/
0x00,0x00,0x00,0x00,0x00,0x80,0x40,0x20,0x10,0xF0,0xF8,0xF8,0x00,0x00,0x00,0x00,
0x00,0x04,0x06,0x05,0x05,0x04,0x24,0x24,0x24,0x3F,0x3F,0x3F,0x24,0x24,0x24,0x00,///*"4"*4/
0x00,0x00,0x00,0xC0,0x38,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x08,0x08,0x00,0x00,
0x00,0x00,0x18,0x29,0x21,0x20,0x20,0x20,0x20,0x20,0x30,0x11,0x1F,0x0E,0x00,0x00,///*"5"*5/
0x00,0x00,0x80,0xE0,0x30,0x10,0x98,0x88,0x88,0x88,0x88,0x88,0x98,0x10,0x00,0x00,
0x00,0x00,0x07,0x0F,0x19,0x31,0x20,0x20,0x20,0x20,0x20,0x20,0x11,0x1F,0x0E,0x00,///*"6"*6/
0x00,0x00,0x30,0x18,0x08,0x08,0x08,0x08,0x08,0x88,0x48,0x28,0x18,0x08,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x3E,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,///*"7"*7/
0x00,0x00,0x70,0x70,0xD8,0x88,0x88,0x08,0x08,0x08,0x08,0x98,0x70,0x70,0x00,0x00,
0x00,0x0C,0x1E,0x12,0x21,0x21,0x20,0x21,0x21,0x21,0x23,0x12,0x1E,0x0C,0x00,0x00,///*"8"*8/
0x00,0xE0,0xF0,0x10,0x08,0x08,0x08,0x08,0x08,0x08,0x18,0x10,0xF0,0xC0,0x00,0x00,
0x00,0x00,0x11,0x33,0x22,0x22,0x22,0x22,0x22,0x32,0x11,0x1D,0x0F,0x03,0x00,0x00,///*"9"*9/
0x10,0x21,0x86,0x70,0x00,0x7E,0x4A,0x4A,0x4A,0x4A,0x4A,0x7E,0x00,0x00,0x00,0x00,
0x02,0xFE,0x01,0x40,0x7F,0x41,0x41,0x7F,0x41,0x41,0x7F,0x41,0x41,0x7F,0x40,0x00,///*"温",10*/
0x00,0x00,0xFC,0x04,0x24,0x24,0xFC,0xA5,0xA6,0xA4,0xFC,0x24,0x24,0x24,0x04,0x00,
0x80,0x60,0x1F,0x80,0x80,0x42,0x46,0x2A,0x12,0x12,0x2A,0x26,0x42,0xC0,0x40,0x00,///*"度",11*/
};
sbit CS1=P1^7;///左半边
sbit CS2=P1^6;///右半边
sbit E=P3^3;///使能信号
sbit RW=P3^4;///读写操作选择
sbit RS=P3^5;///寄存器选择(数据/指令)
sbit RES=P1^5;///复位 低电平有效
sbit BUSY=P2^7;
sbit De=P1^1; ///加热
sbit DQ=P1^4; ///DS18B20单数据总线
uchar TPH,TPL; ///温度值高位 低位
unsigned int t=30; ///温度值
unsigned int t1=30; ///目标温度值
sbit swh1=P3^6;
sbit swh2=P3^7;
uchar flag1=0;
uchar flag2=0;
int I=0;
int error;
int derror;
int lasterror;
int p=2;
int d=5;
int pid;
void send_byte(uchar dat ,uchar cs1,uchar cs2);
void send_all(uint page,uint lie,uint offset);
void delay(uint x);
void init_yejing();
void clearscreen();
void DelayXus(uchar n); ///微秒级延时
void ow_rest(); ///复位
void write_byte(char dat);
unsigned char read_bit(void);
void main(void)
{

init_yejing();
t=0;
while(1)
{
	derror=lasterror;
  lasterror=error;
if(swh1==0)
{
flag1=1;
}
if(swh1==1 && flag1==1)
{
t1++;
flag1=0;
}
if(swh2==0)
flag2=1;
if(swh2==1 && flag2==1)
{
t1--;
flag2=0;
}
error=t1-t;
//if(t<t1)
//De=1;
//else De=0;
if(derror>5)p=p+1;
if(derror<2)p=p-1;
pid=p*error-d*derror;
if(pid>0)De=1;
else De=0;

ow_rest(); ///设备复位
write_byte(0xCC); ///跳过ROM命令
write_byte(0x44); ///开始转换命令
while (!DQ); ///等待转换完成
ow_rest(); ///设备复位
write_byte(0xCC); ///跳过ROM命令
write_byte(0xBE); ///读暂存存储器命令
TPL = read_bit(); ///读温度低字节
TPH = read_bit(); ///读温度高字节
t=TPH; ///取温度高位
t<<=8; ///高位8位
t|=TPL; ///加上温度低位
t*=0.625; ///实际温度 可直接显示
t=t/10;
send_all(1,1,10);///温
send_all(1,2,11);///度
send_all(1,3,12);///:
send_all(4,2,t1/10);///十,目标温度
send_all(4,3,t1%10);///个
send_all(4,5,t/10);///十，实际温度
send_all(4,6,t%10);///个
delay(50000);
clearscreen();
}
}
void DelayXus(uchar n)
{
while (n--)
{
_nop_();
_nop_();
}
}
unsigned char read_bit(void)///读位
{
uchar i;
uchar dat = 0;
for (i=0; i<8; i++) ///8位计数器
{
dat >>= 1;
DQ = 0; ///开始时间片
DelayXus(1); ///延时等待
DQ = 1; ///准备接收
DelayXus(1); ///接收延时
if (DQ)
dat |= 0x80; ///读取数据
DelayXus(60); ///等待时间片结束
}
return dat;
}
void ow_rest()///复位
{
CY = 1;
while (CY)
{
DQ = 0; ///送出低电平复位信号
DelayXus(240); ///延时至少480us
DelayXus(240);
DQ = 1; ///释放数据线
DelayXus(60); ///等待60us
CY = DQ; ///检测存在脉冲,DQ为0转换完成
DelayXus(240); ///等待设备释放数据线
DelayXus(180);
}
}
void write_byte(char dat)///写字节
{
uchar i;
for (i=0; i<8; i++) ///8位计数器
{
DQ = 0; ///开始时间片
DelayXus(1); ///延时等待
//;dat >>= 1; ///送出数据
//;DQ = CY;
	DQ=dat&0x01;
	dat>>=1;
DelayXus(60); ///等待时间片结束
DQ = 1; ///恢复数据线
DelayXus(1); ///恢复延时
}
}
void init_yejing()
{
send_byte(192,1,1);///设置起始行
send_byte(63,1,1);///打开显示开关
}
void send_byte(uchar dat,uchar cs1,uchar cs2)
{
P2=0xff;
CS1=cs1; CS2=cs2;
RS=0; RW=1; E=1;
while(BUSY) ;
///送数据或控制字
E=0;
RS=!(cs1&&cs2),RW=0;
P2=dat;
E=1; delay(3); E=0;
CS1=CS2=0;
}
void send_all(uint page,uint lie,uint offset)
{
uint i,j,k=0;
for(i=0;i<2;++i)
{
send_byte(184+i+page,1,1);///选择页面
send_byte(64+lie*16-(lie>3)*64,1,1);///选择列号
for(j=0;j<16;++j)
send_byte(zima[offset][k++],lie<4,lie>=4);///送数
}
}
void delay(uint x)
{
while(x--) ;
}
void clearscreen()
{
int i,j;
for(i=0;i<8;++i)
{
send_byte(184+i,1,1);///页
send_byte(64,1,1);///列
for(j=0;j<64;++j)
{
send_byte(0x00,0,1);
send_byte(0x00,1,0);
}
}
}