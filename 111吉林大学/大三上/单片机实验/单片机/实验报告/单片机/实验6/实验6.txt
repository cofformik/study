#include <reg52.h>
#include <intrins.h>
#define uchar unsigned char
#define uint unsigned int
//数码管初始化
sfr P4=0xC0;//初始化 P4 端口地址
sfr P4SW=0xBB;//P4SW 默认值 驱动
sbit sclk=P4^4;//模拟串口时钟
sbit sdata=P4^5;//模拟串口数据
//液晶屏初始化
sbit CS1=P1^7;
sbit CS2=P1^6;
sbit E=P3^3;//使能端
sbit RW=P3^4;//读写操作
sbit RS=P3^5;//寄存器选择
sbit RES=P1^5;
sbit BUSY=P2^7;
//直流电机初始化
sbit swh1=P3^6;//开关 S1
sbit swh2=P3^7;//开关 S2
sbit motor=P1^1;//从p1.1输出
uchar code zima[20][32]=
{
0x00,0x00,0xC0,0xE0,0x30,0x10,0x08,0x08,0x08,0x08,0x08,0x18,0x30,0xE0,0xC0,0x00,
0x00,0x00,0x07,0x0F,0x18,0x10,0x20,0x20,0x20,0x20,0x20,0x10,0x18,0x0F,0x07,0x00,///*"0"*0/
0x00,0x00,0x00,0x10,0x10,0x10,0x10,0xF0,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x20,0x20,0x20,0x20,0x3F,0x3F,0x20,0x20,0x20,0x20,0x00,0x00,0x00,//*"1"*1/
0x00,0x00,0x60,0x50,0x10,0x08,0x08,0x08,0x08,0x08,0x08,0x98,0xF0,0x70,0x00,0x00,
0x00,0x00,0x20,0x30,0x28,0x28,0x24,0x24,0x22,0x22,0x21,0x20,0x30,0x18,0x00,0x00,//*"2"*2/
0x00,0x00,0x30,0x30,0x08,0x08,0x88,0x88,0x88,0x88,0x58,0x70,0x30,0x00,0x00,0x00,
0x00,0x00,0x18,0x18,0x20,0x20,0x20,0x20,0x20,0x20,0x31,0x11,0x1F,0x0E,0x00,0x00,//*"3"*3/
0x00,0x00,0x00,0x00,0x00,0x80,0x40,0x20,0x10,0xF0,0xF8,0xF8,0x00,0x00,0x00,0x00,
0x00,0x04,0x06,0x05,0x05,0x04,0x24,0x24,0x24,0x3F,0x3F,0x3F,0x24,0x24,0x24,0x00,//*"4"*4/
0x00,0x00,0x00,0xC0,0x38,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x08,0x08,0x00,0x00,
0x00,0x00,0x18,0x29,0x21,0x20,0x20,0x20,0x20,0x20,0x30,0x11,0x1F,0x0E,0x00,0x00,//*"5"*5/
0x00,0x00,0x80,0xE0,0x30,0x10,0x98,0x88,0x88,0x88,0x88,0x88,0x98,0x10,0x00,0x00,
0x00,0x00,0x07,0x0F,0x19,0x31,0x20,0x20,0x20,0x20,0x20,0x20,0x11,0x1F,0x0E,0x00,//*"6"*6/
0x00,0x00,0x30,0x18,0x08,0x08,0x08,0x08,0x08,0x88,0x48,0x28,0x18,0x08,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x3E,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//*"7"*7/
0x00,0x00,0x70,0x70,0xD8,0x88,0x88,0x08,0x08,0x08,0x08,0x98,0x70,0x70,0x00,0x00,
0x00,0x0C,0x1E,0x12,0x21,0x21,0x20,0x21,0x21,0x21,0x23,0x12,0x1E,0x0C,0x00,0x00,//*"8"*8/
0x00,0xE0,0xF0,0x10,0x08,0x08,0x08,0x08,0x08,0x08,0x18,0x10,0xF0,0xC0,0x00,0x00,
0x00,0x00,0x11,0x33,0x22,0x22,0x22,0x22,0x22,0x32,0x11,0x1D,0x0F,0x03,0x00,0x00,//*"9"*9/
0x08,0x08,0x0A,0xEA,0xAA,0xAA,0xAA,0xFF,0xA9,0xA9,0xA9,0xE9,0x08,0x08,0x08,0x00,
0x40,0x40,0x48,0x4B,0x4A,0x4A,0x4A,0x7F,0x4A,0x4A,0x4A,0x4B,0x48,0x40,0x40,0x00,//*"?"*10/
0x40,0x40,0x40,0xDF,0x55,0x55,0x55,0xD5,0x55,0x55,0x55,0xDF,0x40,0x40,0x40,0x00,
0x40,0x40,0x40,0x57,0x55,0x55,0x55,0x7F,0x55,0x55,0x55,0x57,0x50,0x40,0x40,0x00,//*"?"*11/
0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0xC0,0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x30,0x30,0x00,0x00,0x00,0x00,0x00,0x00,//*":"*12/
0x00,0x04,0x04,0xE4,0x24,0x24,0x24,0x3F,0x24,0x24,0x24,0xE4,0x04,0x04,0x00,0x00,
0x00,0x00,0x80,0x43,0x31,0x0F,0x01,0x01,0x01,0x3F,0x41,0x43,0x40,0x40,0x70,0x00,//*"?"*13/
};
uchar tab[15]= {0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0x0F8,0x80,0x90};//0-9
uchar tspeed=0;//脉冲计数
uchar cspeed=0;//当前转速
uchar xspeed=130;//预定转速
uchar speedUp = 160;//最高转速
uchar speedLow =100;//最低转速
uchar t1_cnt=0; ///1s=50ms*20
//占空比设置
int N=50;
int M=256;
int X=0;
void send_byte(uchar dat ,uchar cs1,uchar cs2);
void send_all(uint page,uint lie,uint offset);
void init();
void clearscreen();
void init_yejing();
void sendbyte(uchar ch);
void display(uchar n);
void delay1();
void delay2();
void delay(uint x)
{
while(x--) ;
}
void main()
{
init();
init_yejing();
motor=0;
while(1)
{
clearscreen();
send_all(1,3,speedLow/100);//最低值百位
send_all(1,4,(speedLow/10)%10);//最低值十位
send_all(1,5,speedLow%10);//最低值个位
send_all(3,3,cspeed/100);//当前值百位
send_all(3,4,(cspeed/10)%10);//当前值十位
send_all(3,5,cspeed%10);//当前值个位
send_all(5,3,speedUp/100);//最高值百位
send_all(5,4,(speedUp/10)%10);//最高值十位
send_all(5,5,speedUp%10);//最高值个位
delay1();
display(cspeed);//数码管显示
delay(50000);
}
}
//数码管和中断初始化
void init()
{ P4SW=0x30;
IT0=1;//1跳变沿触发方式，0电平触发方式
EA=1;//中断使能
EX0=1;//INT0 的中断允许位 为 1 允许	
	
ET1=1;//T1 中断允许位 为 1 时允许响应
ET0=1;//T0 中断允许位 为 1 时允许响应
TMOD=0x11; //16位寄存器，模式1
	
TH1=0x3C;
TL1=0xB0; //50ms:65536-50000=15536
TH0=0xFF;
TL0=0x9C; //0.1ms:65536-100=65436
TR0=1;//计时器 0 是否允许计数
TR1=1;//1
}
//外部中断INT0,转一圈加一，用来测速
//单片机中 51 系列的有 0 1 2 3 4 等几个中断, 中断号与中断事件是绑定的，不能随便设置,对应的中断向量会指向这个函数入口地址
void ex_int0() interrupt 0//interrupt 表明当前是一个中断函数,不需要被主函数直接或间接调用.interrupt 后的数字表明是中断号几
{
tspeed++;
}
//计时器中断0，用来调整占空比
void t0_int() interrupt 1 ///0.1ms
{
TH0=0xFF;
TL0=0x9C;
//累加法
X+=N;
if(X>M)
{
motor=0;
X-=M;
}
else
motor=1;
}
//计时器中断1，用来调整转速
void t1_int() interrupt 3 ///50ms
{
if(++t1_cnt<20)
{ TH1=0x3C;
TL1=0xB0;
if(swh1==0)//S1按下
{
xspeed = speedLow;
}
if(swh2==0)//S2按下
{
xspeed = speedUp;
}
return;
}
t1_cnt=0;
cspeed=tspeed;
tspeed=0;
if(cspeed>xspeed) N--;//降低转速
if(cspeed<xspeed) N++;//提高转速
}
//液晶屏初始化
void init_yejing()
{
send_byte(192,1,1);
send_byte(63,1,1);
}
//送8位数
void send_byte(uchar dat,uchar cs1,uchar cs2)
{
P2=0xff;
CS1=cs1; CS2=cs2;
RS=0; RW=1; E=1;
while(BUSY) ;
E=0;
RS=!(cs1&&cs2),RW=0;
P2=dat;
E=1; delay(3); E=0;
CS1=CS2=0;
}
//显示相应字
void send_all(uint page,uint lie,uint offset)
{
uint i,j,k=0;
for(i=0;i<2;++i)
{
send_byte(184+i+page,1,1);
send_byte(64+lie*16-(lie>3)*64,1,1);
for(j=0;j<16;++j)
send_byte(zima[offset][k++],lie<4,lie>=4);
}
}
//清屏
void clearscreen()
{
int i,j;
for(i=0;i<8;++i)
{
send_byte(184+i,1,1);
send_byte(64,1,1);
for(j=0;j<64;++j)
{
send_byte(0x00,0,1);
send_byte(0x00,1,0);
}
}
}
//数码管显示1个数
void sendbyte(uchar ch)
{
uchar shape,c;
shape=tab[ch];
for(c=0;c<8;c++)
{
sclk=0;//P4.4 串口时针 当有上升沿，会将数据传过去
sdata=shape & 0x80;//P4.5 串口数据 串口的要求是数据一位一位的传 所以在这里还是通过移位 做逻辑与 取一位数据
sclk=1;//制造上升沿，先传一位数据
shape <<= 1;//左移一
}
}
//数码管显示
void display(uchar n)
{
sendbyte(n%10);
sendbyte((n/10)%10);
sendbyte(n/100);
}
void delay1()
{
int i,j;
for(i=0;i<1000;i++)
for(j=0;j<500;j++);
}
void delay2()
{
int i,j;
for(i=0;i<1000;i++)
for(j=0;j<1000;j++);
}
