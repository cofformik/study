;====================================================================
; Main.asm file generated by New Project wizard
;
; Created:   周一 九月 19 2022
; Processor: AT89C51
; Compiler:  ASEM-51 (Proteus)
;====================================================================

$NOMOD51
$INCLUDE (8051.MCU)

;====================================================================
; DEFINITIONS
;====================================================================
CLK BIT P1.4
DAT BIT P1.5

;====================================================================
; VARIABLES
;====================================================================

;====================================================================
; RESET and INTERRUPT VECTORS
;====================================================================

      ; Reset Vector
    org   0000h
    jmp   Start

;====================================================================
; CODE SEGMENT
;====================================================================
ORG 0000H
	LJMP START
ORG 000BH
	LJMP EINT0 

ORG 0040H
;-------------------------------------------------------------------
START:	
	MOV TMOD,#01H	        ;SET T0 AT MODE 1
	MOV TL0,#0DCH            ；设置间隔时间1s
	MOV TH0,#00BH	
	SETB ET0	                        ;ALLOW T0
	SETB TR0		        ;START T0
	SETB EA		        ;START TIMER
	
	mov R2, #20
	mov R1, #2		; 要显示的值，初值设为2

LOOP:                                             ；循环的主程序
	MOV A, R1
	ACALL DISPLAY_A          ；显示R1的值 
	ACALL DELAY
	JMP LOOP
	
;INT0------------------------------------------------------------中端
EINT0:                                             ；每一秒修改一次，修改成下一个素数
	MOV TL0, #0DCH		
	MOV TH0, #00BH             ；每次进入中断时先恢复初值
	DJNZ R2, EINT0_RE
	MOV R2, #20
	
NEXT_PRIME:
	INC R1                                         ；数加一
	CJNE R1, #100, JUDGE_EXE         ；判断到没到100
	MOV R1, #2                                 ；到100了就置为2重新开始	MOV A, R1                                    ；没到100就判断当前数是否为素数
	ACALL JUDGE_PRIME                    ；判断素数的函数，若是素数则A值为1
	JZ NEXT_PRIME                              ；若不是素数A为0，则跳回NEXT_PRIME
	
EINT0_RE:
	RETI

;JUDGE_R1_IS_PRIME------------------------------------------------------------判断是否是素数的函数
JUDGE_PRIME:
	MOV R4,#2                                ；除数
JUDGE_MAX:
	CJNE R1, #100, JUDGE_MIN      ；判断到没到100，没到100跳转到J_MIN
	JMP JUDGE_FALSE                     ；到100了跳转到J_FALSE
JUDGE_MIN:
	CJNE R1, #2, JUDGE_MAIN
	JMP JUDGE_TRUE
JUDGE_MAIN:                                           ；主函数
	MOV A, R1
	MOV B, R4
	DIV AB                                       ；用A除B
	MOV A, B                                   ；B赋值给A，整除 没有余数，A是0
	JZ JUDGE_FALSE                        ；上一句成立，则不是素数，跳转到J_FALSE
	INC R4                                         
	MOV A, R1
	MOV B, R4
	CJNE A, B, JUDGE_MAIN          ；R4加一后判断AB是否相等，不相等就继续除循环，相等就是素数了
JUDGE_TRUE:                                         ；最终结果
	MOV A, #1                              ；A值为1时是素数
	RETI
JUDGE_FALSE:
	MOV A, #0                              ；A值为0时不是素数
	RETI
	
	
;DISPLAY_A------------------------------------------------------------显示部分
DISPLAY_A:

	MOV B,#16           ；为得到16进制
	DIV AB                   ；AB相除，余数在B，B为最后一个数码管要显示的数
	MOV R6, A             ；防止A值丢失，先转存
	
	MOV A, B              ；循环8次，先展示B中的值
	MOV R5, #08H
	MOV DPTR,#TABLE    ；查找TABLE中的码，输出
	MOVC A, @A+DPTR
LOOP1:
	RLC A                     ；进行的是循环左移，因为图中连线关系是反着的
	CLR P1.4
	MOV P1.5,C
	SETB P1.4
	DJNZ R5,LOOP1

	MOV A, R6            ；再输出A中的值
	MOV R5,#08H
	MOV DPTR,#TABLE
	MOVC A,@A+DPTR
LOOP2:
	RLC A
	CLR P1.4
	MOV P1.5,C
	SETB P1.4
	DJNZ R5,LOOP2
	
	MOV R5, #08H       ；最后输出三个数码管中最前面那个0
	MOV A, #00H
LOOP0:
	RLC A
	CLR P1.4
	MOV P1.5,C
	SETB P1.4
	DJNZ R5,LOOP0
	
	RET


;DELAY-------------------------------------------------------------延时
DELAY:
	MOV R5,#2
DEL1:
	MOV R6,#255
DEL2:
	MOV R7, #225
DEL3:
	DJNZ R7,DEL3
	DJNZ R6,DEL2
	DJNZ R5,DEL1
	RET

TABLE:	DB 03fH,006H,05bH,04fH,066H,06dH,07dH,007H,07fH,06fH,077H,07cH,039H,05eH,079H,071H

	END
