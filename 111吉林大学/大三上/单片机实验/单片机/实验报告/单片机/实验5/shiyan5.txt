#include <reg52.h>
#include <intrins.h>
#define uchar unsigned char
#define uint unsigned int
sbit CS1=P1^7;
sbit CS2=P1^6;//选择左右
sbit E=P3^3;//使能信号
sbit RW=P3^4;//读写操作选择
sbit RS=P3^5;//寄存器选择(数据/指令)
sbit RES=P1^5;//复位 低电平有效
sbit BUSY=P2^7;//当前为运行状态

sfr ADC_CONTR = 0xBC; ///ADC control register
sfr ADC_RES = 0xBD; ///ADC hight 8-bit result register
sfr ADC_LOW2 = 0xBE; ///ADC low 2-bit result register
sfr P1ASF = 0x9D;//P1 secondary function control register: P1口模拟功能控制寄存器
sfr AURX1 = 0xA2; //AURX1中的ADRJ位用于转换结果寄存器的数据格式调整控制
#define ADC_POWER 0x80 ///ADC power control bit
#define ADC_FLAG 0x10 ///ADC complete flag
#define ADC_START 0x08 ///ADC start control bit
#define ADC_SPEEDLL 0x00 ///540 clocks
#define ADC_SPEEDL 0x20 ///360 clocks
#define ADC_SPEEDH 0x40 ///180 clocks
#define ADC_SPEEDHH 0x60 ///90 clocks
uchar ch = 0; ///模拟输入通道选择
uchar code zima[20][32]=
{
0x00,0x00,0xC0,0xE0,0x30,0x10,0x08,0x08,0x08,0x08,0x08,0x18,0x30,0xE0,0xC0,0x00,
0x00,0x00,0x07,0x0F,0x18,0x10,0x20,0x20,0x20,0x20,0x20,0x10,0x18,0x0F,0x07,0x00,///*"0"*0/
0x00,0x00,0x00,0x10,0x10,0x10,0x10,0xF0,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x20,0x20,0x20,0x20,0x3F,0x3F,0x20,0x20,0x20,0x20,0x00,0x00,0x00,///*"1"*1/
0x00,0x00,0x60,0x50,0x10,0x08,0x08,0x08,0x08,0x08,0x08,0x98,0xF0,0x70,0x00,0x00,
0x00,0x00,0x20,0x30,0x28,0x28,0x24,0x24,0x22,0x22,0x21,0x20,0x30,0x18,0x00,0x00,///*"2"*2/
0x00,0x00,0x30,0x30,0x08,0x08,0x88,0x88,0x88,0x88,0x58,0x70,0x30,0x00,0x00,0x00,
0x00,0x00,0x18,0x18,0x20,0x20,0x20,0x20,0x20,0x20,0x31,0x11,0x1F,0x0E,0x00,0x00,///*"3"*3/
0x00,0x00,0x00,0x00,0x00,0x80,0x40,0x20,0x10,0xF0,0xF8,0xF8,0x00,0x00,0x00,0x00,
0x00,0x04,0x06,0x05,0x05,0x04,0x24,0x24,0x24,0x3F,0x3F,0x3F,0x24,0x24,0x24,0x00,///*"4"*4/
0x00,0x00,0x00,0xC0,0x38,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x08,0x08,0x00,0x00,
0x00,0x00,0x18,0x29,0x21,0x20,0x20,0x20,0x20,0x20,0x30,0x11,0x1F,0x0E,0x00,0x00,///*"5"*5/
0x00,0x00,0x80,0xE0,0x30,0x10,0x98,0x88,0x88,0x88,0x88,0x88,0x98,0x10,0x00,0x00,
0x00,0x00,0x07,0x0F,0x19,0x31,0x20,0x20,0x20,0x20,0x20,0x20,0x11,0x1F,0x0E,0x00,///*"6"*6/
0x00,0x00,0x30,0x18,0x08,0x08,0x08,0x08,0x08,0x88,0x48,0x28,0x18,0x08,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x3E,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,///*"7"*7/
0x00,0x00,0x70,0x70,0xD8,0x88,0x88,0x08,0x08,0x08,0x08,0x98,0x70,0x70,0x00,0x00,
0x00,0x0C,0x1E,0x12,0x21,0x21,0x20,0x21,0x21,0x21,0x23,0x12,0x1E,0x0C,0x00,0x00,///*"8"*8/
0x00,0xE0,0xF0,0x10,0x08,0x08,0x08,0x08,0x08,0x08,0x18,0x10,0xF0,0xC0,0x00,0x00,
0x00,0x00,0x11,0x33,0x22,0x22,0x22,0x22,0x22,0x32,0x11,0x1D,0x0F,0x03,0x00,0x00,///*"9"*9/
0x08,0x08,0x0A,0xEA,0xAA,0xAA,0xAA,0xFF,0xA9,0xA9,0xA9,0xE9,0x08,0x08,0x08,0x00,
0x40,0x40,0x48,0x4B,0x4A,0x4A,0x4A,0x7F,0x4A,0x4A,0x4A,0x4B,0x48,0x40,0x40,0x00,///*"重"*10/
0x40,0x40,0x40,0xDF,0x55,0x55,0x55,0xD5,0x55,0x55,0x55,0xDF,0x40,0x40,0x40,0x00,
0x40,0x40,0x40,0x57,0x55,0x55,0x55,0x7F,0x55,0x55,0x55,0x57,0x50,0x40,0x40,0x00,///*"量"*11/
0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0xC0,0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x30,0x30,0x00,0x00,0x00,0x00,0x00,0x00,///*":"*12/
0x00,0x04,0x04,0xE4,0x24,0x24,0x24,0x3F,0x24,0x24,0x24,0xE4,0x04,0x04,0x00,0x00,
0x00,0x00,0x80,0x43,0x31,0x0F,0x01,0x01,0x01,0x3F,0x41,0x43,0x40,0x40,0x70,0x00,///*"克"*13/
};
void send_byte(uchar dat ,uchar cs1,uchar cs2);
void send_all(uint page,uint lie,uint offset);
void delay(uint x);
void init_adc();
void init_yejing();
void calibrate();
int get_ad_result();
void clearscreen();
int cweight;//初始重量，用于校准
int weight;//真实重量
void main()
{
init_yejing();//
init_adc();
calibrate();//校准
while(1)
{
weight=(get_ad_result()-cweight)/1.81;
clearscreen();//清屏
send_all(1,1,10);//重
send_all(1,2,11);//量
send_all(1,3,12);//:
send_all(4,3,weight/100);//百
send_all(4,4,(weight/10)%10);//十
send_all(4,5,weight%10);//个
send_all(4,6,13);//克
delay(50000);
}
}
void init_yejing()
	{
send_byte(192,1,1);//设置起始行，规定了显示屏上最顶一行所对应的显示存储器的行地址，默认格式的最高两位是1，所以是在192的基础上加
send_byte(63,1,1);//打开显示开关显示开关设置，默认格式为0011111D，D为1时候显示，为0不显示
}
void send_byte(uchar dat,uchar cs1,uchar cs2)
{
P2=0xff;
CS1=cs1; CS2=cs2;
RS=0; RW=1; E=1;//读状态字
while(BUSY) ;

//送数据或者控制字
E=0;
RS=!(cs1&&cs2),RW=0;//写指令代码
P2=dat;
E=1; delay(3);
E=0;//总线释放
CS1=CS2=0;
}
void send_all(uint page,uint lie,uint offset)
{
uint i,j,k=0;
for(i=0;i<2;++i)
{
send_byte(184+i+page,1,1);//page=0xb8|page;//选择页面 184-页面地址设置，也就是X的设置，默认格式的高五位是10111，所以是在184的基础上加
send_byte(64+lie*16-(lie>3)*64,1,1);//选择列号，也就是Y的设置，默认格式中最高两位是01，所以是在64的基础上加，Y是自动加一的
for(j=0;j<16;++j)
send_byte(zima[offset][k++],lie<4,lie>=4);//送数
}
}
void init_adc()
{
P1ASF = 1;//Set P1.0 as analog input port
AURX1 |= 0X04;//AURX1中的ADRJ位用于转换结果寄存器的数据格式调整控制
ADC_RES = ADC_LOW2 = 0; //Clear previous result
ADC_CONTR = ADC_POWER | ADC_SPEEDLL | ADC_START | ch;//ch=0 ADC channel NO.0
delay(4);//ADC power-on delay and Start A/D conversion
}
int get_ad_result()
{
int ADC_result;
ADC_RES = ADC_LOW2 = 0;
ADC_CONTR = ADC_POWER | ADC_SPEEDLL | ch | ADC_START;
_nop_(); _nop_(); _nop_(); _nop_(); _nop_(); _nop_();//Must wait before inquiry
while (!(ADC_CONTR & ADC_FLAG)); //Wait complete flag
ADC_result = (ADC_RES & 0x03) *256 + ADC_LOW2;//ADC_RES中存高2位
ADC_CONTR &= ~ADC_FLAG;//Close ADC flag位置0
return ADC_result;
}
void calibrate()//校正
{
cweight=get_ad_result();
}
void delay(uint x)
{
while(x--) ; 
}
void clearscreen()
{
int i,j;
for(i=0;i<8;++i)
{
send_byte(184+i,1,1);///10111000|page
send_byte(64,1,1);///01000000|line
for(j=0;j<64;++j)
{
send_byte(0x00,0,1);
send_byte(0x00,1,0);
}}}

